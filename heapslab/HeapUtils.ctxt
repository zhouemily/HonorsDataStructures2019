#BlueJ class context
comment0.target=HeapUtils
comment0.text=\n\ Utility\ methods\ for\ building\ a\ binary\ Max\ Heap\ and\ heap\ operations.\n\n\ @author\ Emily\ Zhou\n\ @version\ 01-08-2019\n\ @sicne\ 12-16-2018\n
comment1.params=heap\ heapSize
comment1.target=void\ buildHeap(java.lang.Comparable[],\ int)
comment1.text=\n\ Build\ a\ Max\ Heap\ with\ a\ specified\ complete\ binary\ tree.\n\ \n\ Algorithm\:\n\ -\ find\ the\ right\ most\ non-leaf\ node\ using\ the\ formula\n\ \ \ when\ a\ complete\ binary\ tree\ is\ represented\ by\ an\ array\n\ \ \ that\ stores\ node\ values\ using\ level\ order\ traversal\n\ -\ call\ heapify()\ on\ the\ right\ most\ non-leaf\ node\n\ -\ do\ the\ same\ by\ finding\ the\ second\ right\ most\ non-leaf\ node;\n\ \ \ then\ the\ third\ right\ most\ non-leaf\ node;\ so-on\ until\n\ \ \ reaches\ the\ root\ node\ of\ binary\ tree\ and\ do\ the\ same\n\ \ \ for\ the\ root\ node\n\ \ \ \n\ Big\ O\ Analysis\:\n\ -\ The\ performance\ is\ determined\ by\ the\ number\ of\ calls\n\ \ \ to\ heapify\ and\ heapify\ performance\n\ -\ The\ number\ calls\ to\ heapify\ is\ ~\ non-leaf\ nodes\n\ \ \ which\ is\ ~\ number\ of\ nodes\ in\ the\ heap\ -\ heapSize\n\ -\ The\ heapify\ performance\ is\ O(subtree\ height)\n\ -\ Hence\ the\ total\ performance\ is\ ~\n\ \ \ sum\ of\ heights\ of\ ~\ number\ of\ nodes\ in\ the\ heap\n\ \ \ and\ according\ to\ a\ known\ theorem\ that\ sum\ is\ ~\n\ \ \ the\ number\ of\ nodes\n\ -\ Hence\ the\ performancen\ is\ O(heapSize)\n\ \n\ @precondition\:\ the\ values\ in\ the\ nodes\ of\ heap\ is\ arranged\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ arbitrary\ way\ and\ stored\ in\ a\ level\ order\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tranversal\ array\ starting\ at\ index\ 1\n\ @postcondition\:\ the\ heap\ contains\ a\ complete\ binary\ tree\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ satisfies\ the\ Max\ Heap\ property\n\ @param\ heap\ a\ complete\ binary\ tree\n\ @param\ heapSize\ the\ number\ of\ nodes\ in\ the\ heap\n
comment2.params=heap\ index\ heapSize
comment2.target=void\ heapify(java.lang.Comparable[],\ int,\ int)
comment2.text=\n\ Rearrange\ nodes\ in\ a\ substree\ so\ that\ it\ satisfies\ the\n\ Max\ Heap\ property\ such\ that\ value\ in\ a\ parent\ node\ is\ greater\n\ than\ or\ equal\ to\ any\ of\ the\ values\ in\ its\ two\ children\ nodes.\n\ \n\ Algorithm\:\n\ -\ compare\ the\ value\ at\ the\ specified\ index\ -\ the\ root\ of\ the\n\ \ \ substree\ to\ be\ heapified\ -\ with\ values\ of\ its\ 2\ children\n\ -\ if\ any\ of\ its\ children's\ value\ is\ greater\ than\ the\ value\n\ \ \ at\ index,\ swap\ that\ child's\ value\ with\ the\ value\ at\ index\n\ -\ after\ the\ swap,\ recursively\ call\ heapify\ with\ the\ index\n\ \ \ of\ the\ swapped\ child\n\ \n\ Big\ O\ Analysis\:\n\ -\ The\ worst\ case\ is\ when\ swap\ happens\ and\ if\ happens\n\ \ \ at\ each\ recursion\ call\ as\ well.\n\ -\ The\ maximum\ recursion\ calls\ at\ worst\ case\ is\n\ \ \ \ ~\ height\ of\ the\ substree\ rooted\ at\ the\ index\n\ -\ The\ method\ itself\ (excluding\ the\ recursion\ call)\n\ \ \ takes\ O(1)\ time\n\ Therefore\ the\ performance\ of\ this\ method\ is\n\ \ \ O(height\ of\ the\ substree\ rooted\ at\ index)\n\ \ \ \n\ @param\ heap\ array\ that\ contains\ the\ heap\ data\ with\n\ \ \ \ \ \ \ \ level\ order\ tranversal\ starting\ at\ index\ 1\n\ @param\ index\ the\ index\ in\ the\ heap\ for\ the\ root\n\ \ \ \ \ \ \ \ of\ the\ substree\ to\ be\ heapified\n\ @param\ heapSize\ the\ size\ of\ the\ heap\ (excluding\ index\ 0)\n
comment3.params=heap\ index1\ index2
comment3.target=void\ swap(java.lang.Comparable[],\ int,\ int)
comment3.text=\n\ Swap\ the\ values\ at\ two\ indices\ in\ an\ array\ of\ heap\ data.\n\ \n\ @precondition\:\ index1\ and\ index2\ are\ within\ the\ array\ range\n\ \n\ @param\ heap\ the\ array\ of\ heap\ data\n\ @param\ index1\ first\ index\n\ @param\ index2\ second\ index\n
comment4.params=heap\ item\ heapSize
comment4.target=java.lang.Comparable[]\ insert(java.lang.Comparable[],\ java.lang.Comparable,\ int)
comment4.text=\n\ Insert\ an\ item\ to\ a\ Max\ Heap\ and\ return\ the\ new\ heap.\n\ \n\ @precondition\:\ a\ heap\ meets\ Max\ Heap\ property\ \ stored\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ a\ level\ order\ tranversal\ array\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ starting\ at\ index\ 1\n\ @postcondition\:\ a\ new\ heap\ meets\ Max\ Heap\ property\ with\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ heap\ size\ of\ original\ heap\ size\ +\ 1\n\ \ \ \ \ \n\ Algorithem\:\n\ -\ allocate\ an\ new\ array\ with\ original\ heap\ size\ +\ 1\n\ -\ copy\ items\ from\ original\ heap\ to\ the\ new\ array\n\ -\ add\ the\ new\ item\ at\ original\ heap\ size\ +\ 1\ position\n\ -\ build\ heap\ for\ the\ new\ array\n\ -\ return\ the\ new\ array\n\ \n\ Big\ O\ Analysis\:\n\ -\ Space\:\ allocate\ array\ which\ is\ O(heapSize)\n\ -\ Although\ build\ heap\ performance\ is\ O(heapSize),\ since\n\ \ \ the\ original\ heap\ is\ already\ a\ binary\ heap\ that\ meets\n\ \ \ the\ Max\ Heap\ property,\ the\ worst\ case\ cost\ is\ \n\ \ \ ~\ actual\ heapify\ operations\n\ \ \ to\ have\ the\ added\ item\ rise\ to\ top\ which\ is\ \n\ \ \ ~\ height\ of\ heap\ \=>\ log(heapSize)\n\ Therefore\ without\ counting\ array\ copy,\ the\ performance\ is\n\ O(log(heapSize))\n\ \n\ @param\ heap\ the\ heap\n\ @param\ item\ the\ item\ to\ add\n\ @param\ heapSize\ the\ size\ of\ the\ heap\n\ @return\ the\ new\ heap\n
comment5.params=heap\ heapSize
comment5.target=java.lang.Comparable\ remove(java.lang.Comparable[],\ int)
comment5.text=\n\ Remove\ and\ return\ the\ root\ element\ in\ a\ Max\ Heap.\n\ \n\ @precondition\:\ a\ heap\ meets\ the\ Max\ Heap\ property\ stored\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ a\ level\ order\ tranversal\ array\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ starting\ at\ index\ 1\n\ @postcondition\:\ the\ new\ heap\ meets\ the\ Max\ Heap\ property\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ with\ heap\ size\ of\ original\ heap\ size\ -\ 1\n\ \n\ Algorithem\:\n\ -\ remove\ swap\ the\ last\ item\ in\ the\ heap\ with\ root\n\ -\ heapify\ the\ heap\ with\ heap\ size\ of\ original\ heap\ size\ -\ 1\n\ -\ return\ the\ root\ item\n\ \n\ Big\ O\ analysis\:\n\ -\ The\ swap\ root\ with\ last\ item\ takes\ constant\ time\ O(1)\n\ -\ Although\ build\ heap\ performance\ is\ O(heapSize),\ since\n\ \ \ the\ original\ heap\ is\ already\ a\ binary\ heap\ that\ meets\n\ \ \ the\ Max\ Heap\ property,\ the\ worst\ case\ cost\ is\ \n\ \ \ ~\ actual\ "heapify"\ operations\n\ \ \ to\ have\ the\ new\ root\ move\ down\ to\ bottom\ \n\ \ \ ~\ height\ of\ heap\ \=>\ log(heapSize)\n\ Therefore\ the\ performance\ is\ O(log(heapSize))\n\ \n\ @param\ heap\ the\ heap\n\ @param\ heapSize\ number\ of\ nodes\ in\ the\ heap\n
comment6.params=heap\ heapSize
comment6.target=void\ heapSort(java.lang.Comparable[],\ int)
comment6.text=\n\ Sort\ array\ of\ data\ using\ Heap.\n\ \n\ @precondition\:\ the\ values\ in\ the\ input\ heap\ array\ is\ arranged\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ arbitrary\ way\ and\ stored\ in\ a\ level\ order\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tranversal\ array\ starting\ at\ index\ 1\n\ @postcondition\:\ heap\ contains\ the\ sorted\ array\ starting\ at\ index\ 1\n\ \n\ Algorithm\:\n\ -\ remove\ the\ root\ item\ from\ the\ binary\ heap\n\ \ \ by\ calling\ the\ remove()\ method\n\ -\ repeat\ the\ above\ until\ no\ more\ items\ in\ the\ heap\n\ \n\ Big\ O\ Analysis\:\n\ -\ Space\:\ allocate\ the\ sorted\ array\ is\ \n\ \ \ \ \ \ \ \ \ \ O(heapSize)\ +\ heapify\ swap\ O(1)\ \=>\ O(heapSize)\n\ -\ There\ are\ total\ ~\ O(heapSize)\ calls\ to\ remove()\n\ -\ Each\ remove()\ call\ is\ O(log(heapSize))\n\ -\ Copy\ sorted\ array\ back\ to\ original\ heap\ is\ O(heapSize)\n\ -\ Therefore\ performance\ is\ O((heapSize)log(heapSize))\n\ \n\ @param\ heap\ a\ binary\ heap\ stored\ in\ array\n\ \ \ \ \ \ \ \ \ \ \ \ \ of\ level\ order\ tranversal\ starting\ at\ index\ 1\n\ @param\ heapSize\ the\ number\ of\ items\ in\ the\ heap\n
comment7.params=heap\ heapSize
comment7.target=void\ printHeap(java.lang.Comparable[],\ int)
comment7.text=\n\ Print\ the\ heap\ array.\n\ \n\ @param\ heap\ a\ heap\ array\ start\ at\ index\ 1\n\ @param\ heapSize\ number\ of\ heap\ elements\n
numComments=8
